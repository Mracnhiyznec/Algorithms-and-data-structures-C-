import numpy as np
import matplotlib.pyplot as plt

# ----------------------------------------------------------------------
#  исходные данные варианта 4
# ----------------------------------------------------------------------
a2 = 4.0                           # коэффициент при второй производной
f  = lambda x: 1.0 - x             # начальное условие  u(0,x)
F  = lambda t, x: x - 1.0          # источник  F(t,x)

# ----------------------------------------------------------------------
#  основной расчёт
# ----------------------------------------------------------------------
def solver_variant4(T=1.0, N=50, M=100):
    """
    Решает задачу варианта 4 методом Кранк–Николсон + прогонка.
      T  – верхняя граница времени,
      N  – число шагов по x  (h = 2/N),
      M  – число шагов по t  (τ = T/M).
    Возвращает сетки x_i, t_j и массив значений u_j_i.
    """
    a, b = 0.0, 2.0                # область по x
    h   = (b - a) / N
    tau = T / M

    x_i = np.linspace(a, b, N + 1) # узлы по x
    t_j = np.linspace(0.0, T, M + 1)

    u   = np.zeros((M + 1, N + 1)) # u[j, i] ≡ u_j_i
    u[0, :] = f(x_i)               # начальное условие

    # коэффициенты схемы (одинаковы для всех внутренних i)
    a_i = -a2 * tau / (2 * h * h)
    b_i =  1.0 + a2 * tau / (      h * h)
    c_i =  a_i                     # симметрично

    for j in range(M):
        # --- краевые условия для слоя j+1 ----------------------------
        lam1 = 1.0
        mu1  = -h * (t_j[j+1] - 1.0)      # из  u0 = u1 - h·(t - 1)

        lam2 = 0.0                        # u_N = 0
        mu2  = 0.0

        # --- правая часть g_i  (i = 1 … N‑1) -------------------------
        g = np.zeros(N + 1)
        for i in range(1, N):
            g[i] = (
                u[j, i] +
                a_i * (u[j, i-1] - 2*u[j, i] + u[j, i+1]) +
                tau * F(t_j[j], x_i[i])
            )

        # --- прямой ход прогонки ------------------------------------
        delta = np.zeros(N + 1)
        eta   = np.zeros(N + 1)

        delta[0] = lam1
        eta[0]   = mu1

        denom = a_i * delta[0] + b_i
        delta[1] = -c_i / denom
        eta[1]   = (g[1] - a_i * eta[0]) / denom

        for i in range(2, N):
            denom = a_i * delta[i-1] + b_i
            delta[i] = -c_i / denom
            eta[i]   = (g[i] - a_i * eta[i-1]) / denom

        # --- обратный ход -------------------------------------------
        u[j+1, N] = (lam2 * eta[N-1] + mu2) / (1.0 - lam2 * delta[N-1])
        for i in range(N-1, -1, -1):
            u[j+1, i] = delta[i] * u[j+1, i+1] + eta[i]

    return x_i, t_j, u

# ----------------------------------------------------------------------
#  визуализация
# ----------------------------------------------------------------------
def plot_solution(x_i, t_j, u):
    X, Tm = np.meshgrid(x_i, t_j)
    fig = plt.figure(figsize=(8, 5))
    ax  = fig.add_subplot(111, projection='3d')
    ax.plot_surface(Tm, X, u, cmap='viridis')
    ax.set_xlabel('t')
    ax.set_ylabel('x')
    ax.set_zlabel('u(t,x)')
    plt.title('Вариант 4: численное решение')
    plt.tight_layout()
    plt.show()

# ----------------------------------------------------------------------
#  запуск
# ----------------------------------------------------------------------
if __name__ == '__main__':
    x, t, u = solver_variant4(T=1.0, N=50, M=100)
    plot_solution(x, t, u)
